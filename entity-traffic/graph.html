<head>
  <meta charset="UTF-8">
  <script src="https://unpkg.com/@hpcc-js/wasm/dist/index.min.js"></script>
  <script> var hpccWasm = window["@hpcc-js/wasm"]; </script>
</head>

<body>
  <div id="output">waiting</div><br>
  <div id="checkboxes">
    <input id="user" type="checkbox"></input><label for="user">User</label>
    <input id="source" type="checkbox"></input><label for="source">Source</label>
    <input id="webserver" type="checkbox"></input><label for="webserver">WebServer</label>
    <input id="backend" type="checkbox"></input><label for="backend">Backend</label>
    <input id="lb" type="checkbox"></input><label for="lb">LB</label>
    <input id="db" type="checkbox"></input><label for="db">DB</label>
  </div>
  <div id="chart"></div>
  <div id="detail"></div>
  <div id="scale"></div>

  <script type=module>

  import { start, User, Source, WebServer, Backend, LoadBalancer, Database } from './objsim.js'

  class View {
    constructor(graph, color) {
      this.model = {}
      this.label = {}
      this.t0 = Date.now()
      this.count = 0
      this.clock = setInterval(() => this.harvest(),100)
      this.graph = graph
      this.color = color
    }

    log(name, details, from) {
      let thing = `${from} -> ${name}`
      this.model[thing] = this.model[thing] || 0
      this.model[thing]++
      this.refresh()
    }

    refresh() {
      let rows = Object.keys(this.model).sort().map(thing => `<tr><td>${thing}<td>${this.model[thing]}</tr>`)
      output.innerHTML = `<table>${rows.join("\n")}</table>`
    }

    harvest() {
      let rows = Object.keys(this.model).sort()
      //display("chart", abstract(rows, 'balancer').map(thing => `${thing} [label="${label[thing]||model[thing]}"]`))
      //rows = rows.filter((k) => !k.startsWith("user ->"))
      this.display(this.graph, rows.map(thing => `${thing} [label="${this.model[thing]}"]`))
    }

    display(elementx, edges) {
      let dot = `digraph { rankdir=LR; node [shape=box style=filled fillcolor=${this.color}]; \n${edges.join("\n")} }`
      hpccWasm.graphviz.layout(dot, "svg", "dot").then(svg => {
        document.getElementById(elementx).innerHTML = svg;
      })
    }
  }

  let service = new View("chart", "gold")
  let serviceDetails = new View("detail", "bisque")
  let scale = new View("scale", "lightgreen")
  start(
    (...args) => service.log(...args),
    (...args) => serviceDetails.log(...args),
    (...args) => scale.log(...args)
  )

  function abstract(rows, detail) {
    let result = []
    let thing
    for (let row of rows) {
      if (row.startsWith("user") && !row.startsWith("user ->")) {
        // ignore
      }
      else if (row.startsWith(detail)) {
        // ignore
      } else if (row.endsWith(detail)) {
        thing = row.replace(detail,'database')
        result.push(thing)
        label[thing] = label[thing] || 0
        label[thing] = model[row]
      } else {
        result.push(row)
      }
    }
    return result
  }

  let checkboxes = [user, source, webserver, backend, lb, db];
  for (let checkbox of checkboxes) {
    checkbox.addEventListener("change", (e) => {
      if (e.target.id == "source") {
        Source.serviceMode = !Source.serviceMode
      }
      if (e.target.id == "user") {
        User.serviceMode = !User.serviceMode
      }
      if (e.target.id == "backend") {
        Backend.serviceMode = !Backend.serviceMode
      }
      if (e.target.id == "webserver") {
        WebServer.serviceMode = !WebServer.serviceMode
      }
      if (e.target.id == "lb") {
        LoadBalancer.serviceMode = !LoadBalancer.serviceMode
      }
      if (e.target.id == "db") {
        Database.serviceMode = !Database.serviceMode
      }
      service.model = {}
      service.label = {}
      serviceDetails.model = {}
      serviceDetails.label = {}
      scale.model = {}
      scale.label = {}
    })
  }
  </script>